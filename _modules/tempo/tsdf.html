<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <link rel="shortcut icon" href="../../_static/favicon.svg"/><meta name="generator" content="sphinx-4.5.0, furo 2022.09.29"/>
        <title>tempo.tsdf - Tempo 0.1.23 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #7C4DFF;
  --color-brand-content: #7C4DFF;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-brand-primary: #7C4DFF;
  --color-brand-content: #7C4DFF;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-brand-primary: #7C4DFF;
  --color-brand-content: #7C4DFF;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Tempo 0.1.23 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../_static/tempo - light background.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../_static/tempo - dark background.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Tempo 0.1.23 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference external" href="https://databricks.com/learn/labs">Databricks Labs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide.html">User Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../reference/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/tempo.tsdf.html">tempo.tsdf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/tempo.intervals.html">tempo.intervals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tempo-team.html">Tempo Team</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../future-roadmap.html">Future Roadmap</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for tempo.tsdf</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyspark.sql.functions</span> <span class="k">as</span> <span class="nn">f</span>
<span class="kn">from</span> <span class="nn">IPython.core.display</span> <span class="kn">import</span> <span class="n">HTML</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span> <span class="k">as</span> <span class="n">ipydisplay</span>
<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">SparkSession</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.column</span> <span class="kn">import</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.window</span> <span class="kn">import</span> <span class="n">Window</span><span class="p">,</span> <span class="n">WindowSpec</span>
<span class="kn">from</span> <span class="nn">scipy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftfreq</span>

<span class="kn">import</span> <span class="nn">tempo.io</span> <span class="k">as</span> <span class="nn">tio</span>
<span class="kn">import</span> <span class="nn">tempo.resample</span> <span class="k">as</span> <span class="nn">rs</span>
<span class="kn">from</span> <span class="nn">tempo.interpol</span> <span class="kn">import</span> <span class="n">Interpolation</span>
<span class="kn">from</span> <span class="nn">tempo.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ENV_CAN_RENDER_HTML</span><span class="p">,</span>
    <span class="n">IS_DATABRICKS</span><span class="p">,</span>
    <span class="n">calculate_time_horizon</span><span class="p">,</span>
    <span class="n">get_display_df</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="TSDF"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF">[docs]</a><span class="k">class</span> <span class="nc">TSDF</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object is the main wrapper over a Spark data frame which allows a user to parallelize time series computations on a Spark data frame by various dimensions. The two dimensions required are partition_cols (list of columns by which to summarize) and ts_col (timestamp column, which can be epoch or TimestampType).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">ts_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;event_ts&quot;</span><span class="p">,</span>
        <span class="n">partition_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sequence_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>
<span class="sd">        :param df:</span>
<span class="sd">        :param ts_col:</span>
<span class="sd">        :param partition_cols:</span>
<span class="sd">        :sequence_col every tsdf allows for a tie-breaker secondary sort key</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__validated_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">ts_col</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
            <span class="k">if</span> <span class="n">partition_cols</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">__validated_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">partition_cols</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">sequence_col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sequence_col</span>

        <span class="c1"># Add customized check for string type for the timestamp.</span>
        <span class="c1"># If we see a string, we will proactively created a double</span>
        <span class="c1"># version of the string timestamp for sorting purposes and</span>
        <span class="c1"># rename to ts_col</span>

        <span class="c1"># TODO : we validate the string is of a specific format. Spark will</span>
        <span class="c1"># convert a valid formatted timestamp string to timestamp type so</span>
        <span class="c1"># this if clause seems unneeded. Perhaps we should check for non-valid</span>
        <span class="c1"># Timestamp string matching then do some pattern matching to extract</span>
        <span class="c1"># the time stamp.</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">ts_col</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span> <span class="o">==</span> <span class="s2">&quot;StringType&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">sample_ts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__validate_ts_string</span><span class="p">(</span><span class="n">sample_ts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_double_ts</span><span class="p">()</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="s2">&quot;double_ts&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make sure DF is ordered by its respective ts_col and partition columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Helper functions</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">__add_double_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a double (epoch) version of the string timestamp out to nanos&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="s2">&quot;nanos&quot;</span><span class="p">,</span>
                <span class="p">(</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">),</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot;0.&quot;</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">),</span> <span class="sa">r</span><span class="s2">&quot;\.&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;long_ts&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;timestamp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;long&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;double_ts&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;long_ts&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;nanos&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;nanos&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;long_ts&quot;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__validate_ts_string</span><span class="p">(</span><span class="n">ts_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate the format for the string using Regex matching for ts_string&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="n">ts_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^(\d</span><span class="si">{4}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">[T| ]\d</span><span class="si">{2}</span><span class="s2">:\d</span><span class="si">{2}</span><span class="s2">:\d</span><span class="si">{2}</span><span class="s2">)(\.\d+)?$&quot;</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ts_pattern</span><span class="p">,</span> <span class="n">ts_text</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Incorrect data format, should be YYYY-MM-DD HH:MM:SS[.nnnnnnnn]&quot;</span>
            <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__validated_column</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">colname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Column names must be of type str; found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead!&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">colname</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">colname</span><span class="si">}</span><span class="s2"> not found in Dataframe&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">colname</span>

    <span class="k">def</span> <span class="nf">__validated_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">colnames</span><span class="p">):</span>
        <span class="c1"># if provided a string, treat it as a single column</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">colnames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">colnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">colnames</span><span class="p">]</span>
        <span class="c1"># otherwise we really should have a list or None</span>
        <span class="k">if</span> <span class="n">colnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">colnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Columns must be of type list, str, or None; found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">colnames</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead!&quot;</span>
            <span class="p">)</span>
        <span class="c1"># validate each column</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__validated_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">colnames</span>

    <span class="k">def</span> <span class="nf">__checkPartitionCols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tsdf_right</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">left_col</span><span class="p">,</span> <span class="n">right_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span> <span class="n">tsdf_right</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_col</span> <span class="o">!=</span> <span class="n">right_col</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;left and right dataframe partition columns should have same name in same order&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__validateTsColMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_tsdf</span><span class="p">):</span>
        <span class="n">left_ts_datatype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">right_ts_datatype</span> <span class="o">=</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">left_ts_datatype</span> <span class="o">!=</span> <span class="n">right_ts_datatype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;left and right dataframe timestamp index columns should have same type&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__addPrefixToColumns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add prefix to all specified columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span>
                <span class="n">col_list</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span> <span class="n">col_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
            <span class="p">),</span>
            <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col_list</span><span class="p">)),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">ts_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span>
            <span class="n">seq_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ts_col</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">])</span>
            <span class="n">seq_col</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span> <span class="n">sequence_col</span><span class="o">=</span><span class="n">seq_col</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__addColumnsFromOtherDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_cols</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add columns from some other DF as lit(None), as pre-step before union.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_df</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">other_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
            <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">other_cols</span><span class="p">)),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">new_df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__combineTSDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts_df_right</span><span class="p">,</span> <span class="n">combined_ts_col</span><span class="p">):</span>
        <span class="n">combined_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">unionByName</span><span class="p">(</span><span class="n">ts_df_right</span><span class="o">.</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
            <span class="n">combined_ts_col</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">ts_df_right</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">combined_df</span><span class="p">,</span> <span class="n">combined_ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getLastRightRow</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">left_ts_col</span><span class="p">,</span>
        <span class="n">right_cols</span><span class="p">,</span>
        <span class="n">sequence_col</span><span class="p">,</span>
        <span class="n">tsPartitionVal</span><span class="p">,</span>
        <span class="n">ignoreNulls</span><span class="p">,</span>
        <span class="n">suppress_null_warning</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get last right value of each right column (inc. right timestamp) for each self.ts_col value</span>

<span class="sd">        self.ts_col, which is the combined time-stamp column of both left and right dataframe, is dropped at the end</span>
<span class="sd">        since it is no longer used in subsequent methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ptntl_sort_keys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="s2">&quot;rec_ind&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sequence_col</span><span class="p">:</span>
            <span class="n">ptntl_sort_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sequence_col</span><span class="p">)</span>

        <span class="n">sort_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">ptntl_sort_keys</span> <span class="k">if</span> <span class="n">col_name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>

        <span class="n">window_spec</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>
            <span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="n">sort_keys</span><span class="p">)</span>
            <span class="o">.</span><span class="n">rowsBetween</span><span class="p">(</span><span class="n">Window</span><span class="o">.</span><span class="n">unboundedPreceding</span><span class="p">,</span> <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ignoreNulls</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tsPartitionVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Disabling null skipping with a partition value is not supported yet.&quot;</span>
                <span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                    <span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">last</span><span class="p">(</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;rec_ind&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
                        <span class="kc">True</span><span class="p">,</span>  <span class="c1"># ignore nulls because it indicates rows from the left side</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">window_spec</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">right_cols</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                    <span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">])[</span><span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                <span class="p">),</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">right_cols</span><span class="p">)),</span>
                <span class="n">df</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">tsPartitionVal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># splitting off the condition as we want different columns in the reduce if implementing the skew AS OF join</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                    <span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">ignoreNulls</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">window_spec</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">right_cols</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">df</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                    <span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">ignoreNulls</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">window_spec</span><span class="p">),</span>
                <span class="p">)</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                    <span class="s2">&quot;non_null_ct&quot;</span> <span class="o">+</span> <span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">right_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">window_spec</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">right_cols</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">left_ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">isNotNull</span><span class="p">())</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">))</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="s2">&quot;rec_ind&quot;</span>
        <span class="p">)</span>

        <span class="c1"># remove the null_ct stats used to record missing values in partitioned as of join</span>
        <span class="k">if</span> <span class="n">tsPartitionVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;non_null&quot;</span><span class="p">):</span>
                    <span class="c1"># Avoid collect() calls when explicitly ignoring the warnings about null values due to lookback window.</span>
                    <span class="c1"># if setting suppress_null_warning to True and warning logger is enabled for other part of the code,</span>
                    <span class="c1"># it would make sense to not log warning in this function while allowing other part of the code to continue to log warning.</span>
                    <span class="c1"># So it makes more sense for and than or on this line</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_null_warning</span> <span class="ow">and</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span>
                    <span class="p">):</span>
                        <span class="n">any_blank_vals</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="n">column</span><span class="p">:</span> <span class="s2">&quot;min&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                        <span class="n">newCol</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;non_null_ct&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">any_blank_vals</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s2">&quot;Column &quot;</span>
                                <span class="o">+</span> <span class="n">newCol</span>
                                <span class="o">+</span> <span class="s2">&quot; had no values within the lookback window. Consider using a larger window to avoid missing values. If this is the first record in the data frame, this warning can be ignored.&quot;</span>
                            <span class="p">)</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">left_ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getTimePartitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tsPartitionVal</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create time-partitions for our data-set. We put our time-stamps into brackets of &lt;tsPartitionVal&gt;. Timestamps</span>
<span class="sd">        are rounded down to the nearest &lt;tsPartitionVal&gt; seconds.</span>

<span class="sd">        We cast our timestamp column to double instead of using f.unix_timestamp, since it provides more precision.</span>

<span class="sd">        Additionally, we make these partitions overlapping by adding a remainder df. This way when calculating the</span>
<span class="sd">        last right timestamp we will not end up with nulls for the first left timestamp in each partition.</span>

<span class="sd">        TODO: change ts_partition to accommodate for higher precision than seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">partition_df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="s2">&quot;ts_col_double&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># double is preferred over unix_timestamp</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="s2">&quot;ts_partition&quot;</span><span class="p">,</span>
                <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">tsPartitionVal</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;ts_col_double&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">tsPartitionVal</span><span class="p">))</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;integer&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="s2">&quot;partition_remainder&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;ts_col_double&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;ts_partition&quot;</span><span class="p">))</span>
                <span class="o">/</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">tsPartitionVal</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;is_original&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>  <span class="c1"># cache it because it&#39;s used twice.</span>

        <span class="c1"># add [1 - fraction] of previous time partition to the next partition.</span>
        <span class="n">remainder_df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">partition_df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;partition_remainder&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fraction</span><span class="p">))</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;ts_partition&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;ts_partition&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">tsPartitionVal</span><span class="p">))</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;is_original&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">partition_df</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">remainder_df</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="s2">&quot;partition_remainder&quot;</span><span class="p">,</span> <span class="s2">&quot;ts_col_double&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;ts_partition&quot;</span><span class="p">])</span>

    <span class="c1">#</span>
    <span class="c1"># Slicing &amp; Selection</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="TSDF.select"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">cols</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pyspark.sql.DataFrame.select() method&#39;s equivalent for TSDF objects</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cols : str or list of strs</span>
<span class="sd">        column names (string).</span>
<span class="sd">        If one of the column names is &#39;*&#39;, that column is expanded to include all columns</span>
<span class="sd">        in the current :class:`TSDF`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        tsdf.select(&#39;*&#39;).collect()</span>
<span class="sd">        [Row(age=2, name=&#39;Alice&#39;), Row(age=5, name=&#39;Bob&#39;)]</span>
<span class="sd">        tsdf.select(&#39;name&#39;, &#39;age&#39;).collect()</span>
<span class="sd">        [Row(name=&#39;Alice&#39;, age=2), Row(name=&#39;Bob&#39;, age=5)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The columns which will be a mandatory requirement while selecting from TSDFs</span>
        <span class="n">seq_col_stub</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">]</span>
        <span class="n">mandatory_cols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">+</span> <span class="n">seq_col_stub</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">mandatory_cols</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cols</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;In TSDF&#39;s select statement original ts_col, partitionCols and seq_col_stub(optional) must be present&quot;</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to slice TSDF by time</span>

<span class="sd">        :param op: string symbol of the operation to perform</span>
<span class="sd">        :type op: str</span>
<span class="sd">        :param target_ts: timestamp on which to filter</span>

<span class="sd">        :return: a TSDF object containing only those records within the time slice specified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># quote our timestamp if its a string</span>
        <span class="n">target_expr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">target_ts</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_ts</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">target_ts</span>
        <span class="n">slice_expr</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">target_expr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sliced_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">slice_expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span>
            <span class="n">sliced_df</span><span class="p">,</span>
            <span class="n">ts_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
            <span class="n">partition_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span>
            <span class="n">sequence_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TSDF.at"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.at">[docs]</a>    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select only records at a given time</span>

<span class="sd">        :param ts: timestamp of the records to select</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing just the records at the given time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__slice</span><span class="p">(</span><span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.before"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.before">[docs]</a>    <span class="k">def</span> <span class="nf">before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select only records before a given time</span>

<span class="sd">        :param ts: timestamp on which to filter records</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing just the records before the given time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__slice</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.atOrBefore"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.atOrBefore">[docs]</a>    <span class="k">def</span> <span class="nf">atOrBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select only records at or before a given time</span>

<span class="sd">        :param ts: timestamp on which to filter records</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing just the records at or before the given time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__slice</span><span class="p">(</span><span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.after"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.after">[docs]</a>    <span class="k">def</span> <span class="nf">after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select only records after a given time</span>

<span class="sd">        :param ts: timestamp on which to filter records</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing just the records after the given time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__slice</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.atOrAfter"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.atOrAfter">[docs]</a>    <span class="k">def</span> <span class="nf">atOrAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select only records at or after a given time</span>

<span class="sd">        :param ts: timestamp on which to filter records</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing just the records at or after the given time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__slice</span><span class="p">(</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.between"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.between">[docs]</a>    <span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select only records in a given range</span>

<span class="sd">        :param start_ts: starting time of the range to select</span>
<span class="sd">        :param end_ts: ending time of the range to select</span>
<span class="sd">        :param inclusive: whether the range is inclusive of the endpoints or not, defaults to True</span>
<span class="sd">        :type inclusive: bool</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing just the records within the range specified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inclusive</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atOrAfter</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span><span class="o">.</span><span class="n">atOrBefore</span><span class="p">(</span><span class="n">end_ts</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span><span class="o">.</span><span class="n">before</span><span class="p">(</span><span class="n">end_ts</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__top_rows_per_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">win</span><span class="p">:</span> <span class="n">WindowSpec</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to select just the top n rows per series (as defined by a window ordering)</span>

<span class="sd">        :param win: the window on which we order the rows in each series</span>
<span class="sd">        :param n: the number of rows to return</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing just the top n rows in each series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row_num_col</span> <span class="o">=</span> <span class="s2">&quot;__row_num&quot;</span>
        <span class="n">prev_records_df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">row_num_col</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">win</span><span class="p">))</span>
            <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">row_num_col</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">row_num_col</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span>
            <span class="n">prev_records_df</span><span class="p">,</span>
            <span class="n">ts_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
            <span class="n">partition_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span>
            <span class="n">sequence_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TSDF.earliest"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.earliest">[docs]</a>    <span class="k">def</span> <span class="nf">earliest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the earliest n records for each series</span>

<span class="sd">        :param n: number of records to select (default is 1)</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing the earliest n records for each series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev_window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__baseWindow</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__top_rows_per_series</span><span class="p">(</span><span class="n">prev_window</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.latest"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.latest">[docs]</a>    <span class="k">def</span> <span class="nf">latest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the latest n records for each series</span>

<span class="sd">        :param n: number of records to select (default is 1)</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing the latest n records for each series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">next_window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__baseWindow</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__top_rows_per_series</span><span class="p">(</span><span class="n">next_window</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.priorTo"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.priorTo">[docs]</a>    <span class="k">def</span> <span class="nf">priorTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the n most recent records prior to a given time</span>
<span class="sd">        You can think of this like an &#39;asOf&#39; select - it selects the records as of a particular time</span>

<span class="sd">        :param ts: timestamp on which to filter records</span>
<span class="sd">        :param n: number of records to select (default is 1)</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing the n records prior to the given time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atOrBefore</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">.</span><span class="n">latest</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.subsequentTo"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.subsequentTo">[docs]</a>    <span class="k">def</span> <span class="nf">subsequentTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the n records subsequent to a give time</span>

<span class="sd">        :param ts: timestamp on which to filter records</span>
<span class="sd">        :param n: number of records to select (default is 1)</span>

<span class="sd">        :return: a :class:`~tsdf.TSDF` object containing the n records subsequent to the given time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atOrAfter</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">.</span><span class="n">earliest</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Display functions</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="TSDF.show"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vertical</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pyspark.sql.DataFrame.show() method&#39;s equivalent for TSDF objects</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">        Number of rows to show.</span>
<span class="sd">        truncate : bool or int, optional</span>
<span class="sd">        If set to ``True``, truncate strings longer than 20 chars by default.</span>
<span class="sd">        If set to a number greater than one, truncates long strings to length ``truncate``</span>
<span class="sd">        and align cells right.</span>
<span class="sd">        vertical : bool, optional</span>
<span class="sd">        If set to ``True``, print output rows vertically (one line</span>
<span class="sd">        per column value).</span>

<span class="sd">        Example to show usage</span>
<span class="sd">        ---------------------</span>
<span class="sd">        from pyspark.sql.functions import *</span>

<span class="sd">        phone_accel_df = spark.read.format(&quot;csv&quot;).option(&quot;header&quot;, &quot;true&quot;).load(&quot;dbfs:/home/tempo/Phones_accelerometer&quot;).withColumn(&quot;event_ts&quot;, (col(&quot;Arrival_Time&quot;).cast(&quot;double&quot;)/1000).cast(&quot;timestamp&quot;)).withColumn(&quot;x&quot;, col(&quot;x&quot;).cast(&quot;double&quot;)).withColumn(&quot;y&quot;, col(&quot;y&quot;).cast(&quot;double&quot;)).withColumn(&quot;z&quot;, col(&quot;z&quot;).cast(&quot;double&quot;)).withColumn(&quot;event_ts_dbl&quot;, col(&quot;event_ts&quot;).cast(&quot;double&quot;))</span>

<span class="sd">        from tempo import *</span>

<span class="sd">        phone_accel_tsdf = TSDF(phone_accel_df, ts_col=&quot;event_ts&quot;, partition_cols = [&quot;User&quot;])</span>

<span class="sd">        # Call show method here</span>
<span class="sd">        phone_accel_tsdf.show()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># validate k &lt;= n</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter k </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> cannot be greater than parameter n </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">IS_DATABRICKS</span> <span class="ow">and</span> <span class="n">ENV_CAN_RENDER_HTML</span><span class="p">:</span>
            <span class="c1"># In Jupyter notebooks, for wide dataframes the below line will enable</span>
            <span class="c1"># rendering the output in a scrollable format.</span>
            <span class="n">ipydisplay</span><span class="p">(</span>
                <span class="n">HTML</span><span class="p">(</span><span class="s2">&quot;&lt;style&gt;pre { white-space: pre !important; }&lt;/style&gt;&quot;</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">get_display_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">truncate</span><span class="p">,</span> <span class="n">vertical</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.describe"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Describe a TSDF object using a global summary across all time series (anywhere from 10 to millions) as well as the standard Spark data frame stats. Missing vals</span>
<span class="sd">        Summary</span>
<span class="sd">        global - unique time series based on partition columns, min/max times, granularity - lowest precision in the time series timestamp column</span>
<span class="sd">        count / mean / stddev / min / max - standard Spark data frame describe() output</span>
<span class="sd">        missing_vals_pct - percentage (from 0 to 100) of missing values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># extract the double version of the timestamp column to summarize</span>
        <span class="n">double_ts_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span> <span class="o">+</span> <span class="s2">&quot;_dbl&quot;</span>

        <span class="n">this_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">double_ts_col</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">))</span>

        <span class="c1"># summary missing value percentages</span>
        <span class="n">missing_vals</span> <span class="o">=</span> <span class="n">this_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="mi">100</span>
                    <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">isNull</span><span class="p">(),</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="o">/</span> <span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">this_df</span><span class="o">.</span><span class="n">dtypes</span>
                <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;timestamp&quot;</span>
            <span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot;missing_vals_pct&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;summary&quot;</span><span class="p">),</span> <span class="s2">&quot;*&quot;</span><span class="p">)</span>

        <span class="c1"># describe stats</span>
        <span class="n">desc_stats</span> <span class="o">=</span> <span class="n">this_df</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">missing_vals</span><span class="p">)</span>
        <span class="n">unique_ts</span> <span class="o">=</span> <span class="n">this_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

        <span class="n">max_ts</span> <span class="o">=</span> <span class="n">this_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;max_ts&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span>
            <span class="mi">0</span>
        <span class="p">]</span>
        <span class="n">min_ts</span> <span class="o">=</span> <span class="n">this_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;max_ts&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span>
            <span class="mi">0</span>
        <span class="p">]</span>
        <span class="n">gran</span> <span class="o">=</span> <span class="n">this_df</span><span class="o">.</span><span class="n">selectExpr</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;min(case when {0} - cast({0} as integer) &gt; 0 then &#39;1-millis&#39;</span>
<span class="sd">                  when {0} % 60 != 0 then &#39;2-seconds&#39;</span>
<span class="sd">                  when {0} % 3600 != 0 then &#39;3-minutes&#39;</span>
<span class="sd">                  when {0} % 86400 != 0 then &#39;4-hours&#39;</span>
<span class="sd">                  else &#39;5-days&#39; end) granularity&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">double_ts_col</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">non_summary_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">desc_stats</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s2">&quot;summary&quot;</span><span class="p">]</span>

        <span class="n">desc_stats</span> <span class="o">=</span> <span class="n">desc_stats</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;summary&quot;</span><span class="p">),</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;unique_ts_count&quot;</span><span class="p">),</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;min_ts&quot;</span><span class="p">),</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;max_ts&quot;</span><span class="p">),</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;granularity&quot;</span><span class="p">),</span>
            <span class="o">*</span><span class="n">non_summary_cols</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># add in single record with global summary attributes and the previously computed missing value and Spark data frame describe stats</span>
        <span class="n">global_smry_rec</span> <span class="o">=</span> <span class="n">desc_stats</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;summary&quot;</span><span class="p">),</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">unique_ts</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;unique_ts_count&quot;</span><span class="p">),</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">min_ts</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;min_ts&quot;</span><span class="p">),</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">max_ts</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;max_ts&quot;</span><span class="p">),</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">gran</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;granularity&quot;</span><span class="p">),</span>
            <span class="o">*</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">non_summary_cols</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">full_smry</span> <span class="o">=</span> <span class="n">global_smry_rec</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">desc_stats</span><span class="p">)</span>
        <span class="n">full_smry</span> <span class="o">=</span> <span class="n">full_smry</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span>
            <span class="s2">&quot;unique_ts_count&quot;</span><span class="p">,</span> <span class="s2">&quot;unique_time_series_count&quot;</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">dbutils</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">full_smry</span>
        <span class="c1"># TODO: Can we raise something other than generic Exception?</span>
        <span class="c1">#  perhaps refactor to check for IS_DATABRICKS</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">full_smry</span>
            <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">__getBytesFromPlan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">spark</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal helper function to obtain how many bytes in memory the Spark data</span>
<span class="sd">        frame is likely to take up. This is an upper bound and is obtained from the</span>
<span class="sd">        plan details in Spark</span>

<span class="sd">        Parameters</span>
<span class="sd">        :param df - input Spark data frame - the AS OF join has 2 data frames; this will be called for each</span>
<span class="sd">        :param spark - Spark session which is used to query the view obtained from the Spark data frame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="p">(</span><span class="s2">&quot;view&quot;</span><span class="p">)</span>
        <span class="n">plan</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;explain cost select * from view&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="kn">import</span> <span class="nn">re</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;sizeInBytes=.*([&#39;\)])&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
            <span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># perform to MB for threshold check</span>
        <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;GiB&quot;</span><span class="p">:</span>
            <span class="nb">bytes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="k">elif</span> <span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;MiB&quot;</span><span class="p">:</span>
            <span class="nb">bytes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="k">elif</span> <span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;KiB&quot;</span><span class="p">:</span>
            <span class="nb">bytes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">bytes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">bytes</span>

<div class="viewcode-block" id="TSDF.asofJoin"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.asofJoin">[docs]</a>    <span class="k">def</span> <span class="nf">asofJoin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">right_tsdf</span><span class="p">,</span>
        <span class="n">left_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">right_prefix</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="n">tsPartitionVal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fraction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">skipNulls</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">sql_join_opt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_null_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs an as-of join between two time-series. If a tsPartitionVal is</span>
<span class="sd">        specified, it will do this partitioned by time brackets, which can help alleviate skew.</span>

<span class="sd">        NOTE: partition cols have to be the same for both Dataframes. We are</span>
<span class="sd">        collecting stats when the WARNING level is enabled also.</span>

<span class="sd">        Parameters</span>
<span class="sd">        :param right_tsdf - right-hand data frame containing columns to merge in</span>
<span class="sd">        :param left_prefix - optional prefix for base data frame</span>
<span class="sd">        :param right_prefix - optional prefix for right-hand data frame</span>
<span class="sd">        :param tsPartitionVal - value to break up each partition into time brackets</span>
<span class="sd">        :param fraction - overlap fraction</span>
<span class="sd">        :param skipNulls - whether to skip nulls when joining in values</span>
<span class="sd">        :param sql_join_opt - if set to True, will use standard Spark SQL join if it is estimated to be efficient</span>
<span class="sd">        :param suppress_null_warning - when tsPartitionVal is specified, will collect min of each column and raise warnings about null values, set to True to avoid</span>
<span class="sd">        :param tolerance - only join values within this tolerance range, expressed in number of seconds as an int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first block of logic checks whether a standard range join will suffice</span>
        <span class="n">left_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="n">right_df</span> <span class="o">=</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">df</span>

        <span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
        <span class="n">left_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getBytesFromPlan</span><span class="p">(</span><span class="n">left_df</span><span class="p">,</span> <span class="n">spark</span><span class="p">)</span>
        <span class="n">right_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getBytesFromPlan</span><span class="p">(</span><span class="n">right_df</span><span class="p">,</span> <span class="n">spark</span><span class="p">)</span>

        <span class="c1"># choose 30MB as the cutoff for the broadcast</span>
        <span class="n">bytes_threshold</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="k">if</span> <span class="n">sql_join_opt</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">left_bytes</span> <span class="o">&lt;</span> <span class="n">bytes_threshold</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">right_bytes</span> <span class="o">&lt;</span> <span class="n">bytes_threshold</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">spark</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;spark.databricks.optimizer.rangeJoin.binSize&quot;</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
            <span class="n">partition_cols</span> <span class="o">=</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">partitionCols</span>
            <span class="n">left_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">left_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)))</span>
            <span class="n">right_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">right_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">right_tsdf</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="n">left_prefix</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">left_prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">left_prefix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
                <span class="k">else</span> <span class="n">left_prefix</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
            <span class="p">)</span>
            <span class="n">right_prefix</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">right_prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">right_prefix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
                <span class="k">else</span> <span class="n">right_prefix</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
            <span class="p">)</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="o">*</span><span class="n">partition_cols</span><span class="p">)</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span>
                <span class="n">right_prefix</span> <span class="o">+</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span>
            <span class="p">)</span>

            <span class="n">new_left_ts_col</span> <span class="o">=</span> <span class="n">left_prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span>
            <span class="n">new_left_cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">left_prefix</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">left_cols</span>
            <span class="p">]</span> <span class="o">+</span> <span class="n">partition_cols</span>
            <span class="n">new_right_cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">right_prefix</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">right_cols</span>
            <span class="p">]</span> <span class="o">+</span> <span class="n">partition_cols</span>
            <span class="n">quotes_df_w_lag</span> <span class="o">=</span> <span class="n">right_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">new_right_cols</span><span class="p">)</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="s2">&quot;lead_&quot;</span> <span class="o">+</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
                <span class="n">f</span><span class="o">.</span><span class="n">lead</span><span class="p">(</span><span class="n">right_prefix</span> <span class="o">+</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">left_df</span> <span class="o">=</span> <span class="n">left_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">new_left_cols</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">left_df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">quotes_df_w_lag</span><span class="p">,</span> <span class="n">partition_cols</span><span class="p">)</span>
                <span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">left_df</span><span class="p">[</span><span class="n">new_left_ts_col</span><span class="p">]</span><span class="o">.</span><span class="n">between</span><span class="p">(</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">right_prefix</span> <span class="o">+</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">),</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;lead_&quot;</span> <span class="o">+</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">),</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot;2099-01-01&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;timestamp&quot;</span><span class="p">),</span>
                        <span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;lead_&quot;</span> <span class="o">+</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">partition_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span> <span class="n">ts_col</span><span class="o">=</span><span class="n">new_left_ts_col</span><span class="p">)</span>

        <span class="c1"># end of block checking to see if standard Spark SQL join will work</span>

        <span class="k">if</span> <span class="n">tsPartitionVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;You are using the skew version of the AS OF join. This may result in null values if there are any values outside of the maximum lookback. For maximum efficiency, choose smaller values of maximum lookback, trading off performance and potential blank AS OF values for sparse keys&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check whether partition columns have same name in both dataframes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__checkPartitionCols</span><span class="p">(</span><span class="n">right_tsdf</span><span class="p">)</span>

        <span class="c1"># prefix non-partition columns, to avoid duplicated columns.</span>
        <span class="n">left_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="n">right_df</span> <span class="o">=</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">df</span>

        <span class="c1"># validate timestamp datatypes match</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__validateTsColMatch</span><span class="p">(</span><span class="n">right_tsdf</span><span class="p">)</span>

        <span class="n">orig_left_col_diff</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">left_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">orig_right_col_diff</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">right_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">left_tsdf</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__addPrefixToColumns</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span> <span class="o">+</span> <span class="n">orig_left_col_diff</span><span class="p">,</span> <span class="n">left_prefix</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">left_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span>
        <span class="p">)</span>
        <span class="n">right_tsdf</span> <span class="o">=</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">__addPrefixToColumns</span><span class="p">(</span>
            <span class="p">[</span><span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span> <span class="o">+</span> <span class="n">orig_right_col_diff</span><span class="p">,</span> <span class="n">right_prefix</span>
        <span class="p">)</span>

        <span class="n">left_nonpartition_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">left_tsdf</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">right_nonpartition_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">right_tsdf</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># For both dataframes get all non-partition columns (including ts_col)</span>
        <span class="n">left_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span> <span class="o">+</span> <span class="n">left_nonpartition_cols</span>
        <span class="n">right_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span> <span class="o">+</span> <span class="n">right_nonpartition_cols</span>

        <span class="c1"># Union both dataframes, and create a combined TS column</span>
        <span class="n">combined_ts_col</span> <span class="o">=</span> <span class="s2">&quot;combined_ts&quot;</span>
        <span class="n">combined_df</span> <span class="o">=</span> <span class="n">left_tsdf</span><span class="o">.</span><span class="n">__addColumnsFromOtherDF</span><span class="p">(</span><span class="n">right_columns</span><span class="p">)</span><span class="o">.</span><span class="n">__combineTSDF</span><span class="p">(</span>
            <span class="n">right_tsdf</span><span class="o">.</span><span class="n">__addColumnsFromOtherDF</span><span class="p">(</span><span class="n">left_columns</span><span class="p">),</span> <span class="n">combined_ts_col</span>
        <span class="p">)</span>
        <span class="n">combined_df</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
            <span class="s2">&quot;rec_ind&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">left_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">isNotNull</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># perform asof join.</span>
        <span class="k">if</span> <span class="n">tsPartitionVal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">asofDF</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">__getLastRightRow</span><span class="p">(</span>
                <span class="n">left_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
                <span class="n">right_columns</span><span class="p">,</span>
                <span class="n">right_tsdf</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">,</span>
                <span class="n">tsPartitionVal</span><span class="p">,</span>
                <span class="n">skipNulls</span><span class="p">,</span>
                <span class="n">suppress_null_warning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tsPartitionDF</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">__getTimePartitions</span><span class="p">(</span>
                <span class="n">tsPartitionVal</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="n">fraction</span>
            <span class="p">)</span>
            <span class="n">asofDF</span> <span class="o">=</span> <span class="n">tsPartitionDF</span><span class="o">.</span><span class="n">__getLastRightRow</span><span class="p">(</span>
                <span class="n">left_tsdf</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
                <span class="n">right_columns</span><span class="p">,</span>
                <span class="n">right_tsdf</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">,</span>
                <span class="n">tsPartitionVal</span><span class="p">,</span>
                <span class="n">skipNulls</span><span class="p">,</span>
                <span class="n">suppress_null_warning</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Get rid of overlapped data and the extra columns generated from timePartitions</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">asofDF</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;is_original&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
                <span class="s2">&quot;ts_partition&quot;</span><span class="p">,</span> <span class="s2">&quot;is_original&quot;</span>
            <span class="p">)</span>

            <span class="n">asofDF</span> <span class="o">=</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">asofDF</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">asofDF</span><span class="o">.</span><span class="n">df</span>
            <span class="n">left_ts_col</span> <span class="o">=</span> <span class="n">left_tsdf</span><span class="o">.</span><span class="n">ts_col</span>
            <span class="n">right_ts_col</span> <span class="o">=</span> <span class="n">right_tsdf</span><span class="o">.</span><span class="n">ts_col</span>
            <span class="n">tolerance_condition</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="p">[</span><span class="n">left_ts_col</span><span class="p">]</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="n">right_ts_col</span><span class="p">]</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
                <span class="o">&gt;</span> <span class="n">tolerance</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">right_col</span> <span class="ow">in</span> <span class="n">right_columns</span><span class="p">:</span>
                <span class="c1"># First set right non-timestamp columns to null for rows outside of tolerance band</span>
                <span class="k">if</span> <span class="n">right_col</span> <span class="o">!=</span> <span class="n">right_ts_col</span><span class="p">:</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                        <span class="n">right_col</span><span class="p">,</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">tolerance_condition</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span>
                            <span class="n">df</span><span class="p">[</span><span class="n">right_col</span><span class="p">]</span>
                        <span class="p">),</span>
                    <span class="p">)</span>

            <span class="c1"># Finally, set right timestamp column to null for rows outside of tolerance band</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="n">right_ts_col</span><span class="p">,</span>
                <span class="n">f</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">tolerance_condition</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">right_ts_col</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="n">asofDF</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>

        <span class="k">return</span> <span class="n">asofDF</span></div>

    <span class="k">def</span> <span class="nf">__baseWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># figure out our sorting columns</span>
        <span class="n">primary_sort_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">sort_col</span> <span class="k">else</span> <span class="n">sort_col</span>
        <span class="n">sort_cols</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">primary_sort_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span>
            <span class="k">else</span> <span class="p">[</span><span class="n">primary_sort_col</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># are we ordering forwards (default) or reveresed?</span>
        <span class="n">col_fn</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">col_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">colname</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span><span class="o">.</span><span class="n">desc</span><span class="p">()</span>  <span class="c1"># noqa E731</span>

        <span class="c1"># our window will be sorted on our sort_cols in the appropriate direction</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">Window</span><span class="p">()</span><span class="o">.</span><span class="n">orderBy</span><span class="p">([</span><span class="n">col_fn</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">sort_cols</span><span class="p">])</span>
        <span class="c1"># and partitioned by any series IDs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">w</span>

    <span class="k">def</span> <span class="nf">__rangeBetweenWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_from</span><span class="p">,</span> <span class="n">range_to</span><span class="p">,</span> <span class="n">sort_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__baseWindow</span><span class="p">(</span><span class="n">sort_col</span><span class="o">=</span><span class="n">sort_col</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span><span class="o">.</span><span class="n">rangeBetween</span><span class="p">(</span>
            <span class="n">range_from</span><span class="p">,</span> <span class="n">range_to</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rowsBetweenWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows_from</span><span class="p">,</span> <span class="n">rows_to</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__baseWindow</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span><span class="o">.</span><span class="n">rowsBetween</span><span class="p">(</span><span class="n">rows_from</span><span class="p">,</span> <span class="n">rows_to</span><span class="p">)</span>

<div class="viewcode-block" id="TSDF.withPartitionCols"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.withPartitionCols">[docs]</a>    <span class="k">def</span> <span class="nf">withPartitionCols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partitionCols</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets certain columns of the TSDF as partition columns. Partition columns are those that differentiate distinct timeseries</span>
<span class="sd">        from each other.</span>
<span class="sd">        :param partitionCols: a list of columns used to partition distinct timeseries</span>
<span class="sd">        :return: a TSDF object with the given partition columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">partitionCols</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">vwap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">volume_col</span><span class="o">=</span><span class="s2">&quot;volume&quot;</span><span class="p">,</span> <span class="n">price_col</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="p">):</span>
        <span class="c1"># set pre_vwap as self or enrich with the frequency</span>
        <span class="n">pre_vwap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="n">frequency</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
            <span class="n">pre_vwap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="s2">&quot;time_group&quot;</span><span class="p">,</span>
                <span class="n">f</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">lpad</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">hour</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)),</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">),</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">),</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">lpad</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">minute</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)),</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">),</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">frequency</span> <span class="o">==</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span>
            <span class="n">pre_vwap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="s2">&quot;time_group&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lpad</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">hour</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)),</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">frequency</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span><span class="p">:</span>
            <span class="n">pre_vwap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="s2">&quot;time_group&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lpad</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">day</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)),</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">group_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;time_group&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">:</span>
            <span class="n">group_cols</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>
        <span class="n">vwapped</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pre_vwap</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;dllr_value&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">price_col</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">volume_col</span><span class="p">))</span>
            <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_cols</span><span class="p">)</span>
            <span class="o">.</span><span class="n">agg</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">(</span><span class="s2">&quot;dllr_value&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;dllr_value&quot;</span><span class="p">),</span>
                <span class="nb">sum</span><span class="p">(</span><span class="n">volume_col</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">volume_col</span><span class="p">),</span>
                <span class="nb">max</span><span class="p">(</span><span class="n">price_col</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">price_col</span><span class="p">])),</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;vwap&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;dllr_value&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">volume_col</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">vwapped</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>

<div class="viewcode-block" id="TSDF.EMA"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.EMA">[docs]</a>    <span class="k">def</span> <span class="nf">EMA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colName</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">exp_factor</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs an approximate EMA in the fashion of:</span>
<span class="sd">        EMA = e * lag(col,0) + e * (1 - e) * lag(col, 1) + e * (1 - e)^2 * lag(col, 2) etc, up until window</span>
<span class="sd">        TODO: replace case when statement with coalesce</span>
<span class="sd">        TODO: add in time partitions functionality (what is the overlap fraction?)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">emaColName</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;EMA&quot;</span><span class="p">,</span> <span class="n">colName</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">emaColName</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__baseWindow</span><span class="p">()</span>
        <span class="c1"># Generate all the lag columns:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
            <span class="n">lagColName</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;lag&quot;</span><span class="p">,</span> <span class="n">colName</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">exp_factor</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">exp_factor</span><span class="p">)</span> <span class="o">**</span> <span class="n">i</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">lagColName</span><span class="p">,</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">lag</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">colName</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="n">emaColName</span><span class="p">,</span>
                <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">emaColName</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">lagColName</span><span class="p">)</span><span class="o">.</span><span class="n">isNull</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">lagColName</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">lagColName</span><span class="p">)</span>
            <span class="c1"># Nulls are currently removed</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.withLookbackFeatures"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.withLookbackFeatures">[docs]</a>    <span class="k">def</span> <span class="nf">withLookbackFeatures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">featureCols</span><span class="p">,</span> <span class="n">lookbackWindowSize</span><span class="p">,</span> <span class="n">exactSize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">featureColName</span><span class="o">=</span><span class="s2">&quot;features&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a 2-D feature tensor suitable for training an ML model to predict current values from the history of</span>
<span class="sd">        some set of features. This function creates a new column containing, for each observation, a 2-D array of the values</span>
<span class="sd">        of some number of other columns over a trailing &quot;lookback&quot; window from the previous observation up to some maximum</span>
<span class="sd">        number of past observations.</span>

<span class="sd">        :param featureCols: the names of one or more feature columns to be aggregated into the feature column</span>
<span class="sd">        :param lookbackWindowSize: The size of lookback window (in terms of past observations). Must be an integer &gt;= 1</span>
<span class="sd">        :param exactSize: If True (the default), then the resulting DataFrame will only include observations where the</span>
<span class="sd">          generated feature column contains arrays of length lookbackWindowSize. This implies that it will truncate</span>
<span class="sd">          observations that occurred less than lookbackWindowSize from the start of the timeseries. If False, no truncation</span>
<span class="sd">          occurs, and the column may contain arrays less than lookbackWindowSize in length.</span>
<span class="sd">        :param featureColName: The name of the feature column to be generated. Defaults to &quot;features&quot;</span>
<span class="sd">        :return: a DataFrame with a feature column named featureColName containing the lookback feature tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first, join all featureCols into a single array column</span>
        <span class="n">tempArrayColName</span> <span class="o">=</span> <span class="s2">&quot;__TempArrayCol&quot;</span>
        <span class="n">feat_array_tsdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">tempArrayColName</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">featureCols</span><span class="p">))</span>

        <span class="c1"># construct a lookback array</span>
        <span class="n">lookback_win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rowsBetweenWindow</span><span class="p">(</span><span class="o">-</span><span class="n">lookbackWindowSize</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lookback_tsdf</span> <span class="o">=</span> <span class="n">feat_array_tsdf</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
            <span class="n">featureColName</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">collect_list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">tempArrayColName</span><span class="p">))</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">lookback_win</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">tempArrayColName</span><span class="p">)</span>

        <span class="c1"># make sure only windows of exact size are allowed</span>
        <span class="k">if</span> <span class="n">exactSize</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lookback_tsdf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">featureColName</span><span class="p">)</span> <span class="o">==</span> <span class="n">lookbackWindowSize</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">lookback_tsdf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.withRangeStats"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.withRangeStats">[docs]</a>    <span class="k">def</span> <span class="nf">withRangeStats</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;range&quot;</span><span class="p">,</span> <span class="n">colsToSummarize</span><span class="o">=</span><span class="p">[],</span> <span class="n">rangeBackWindowSecs</span><span class="o">=</span><span class="mi">1000</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a wider set of stats based on all numeric columns by default</span>
<span class="sd">        Users can choose which columns they want to summarize also. These stats are:</span>
<span class="sd">        mean/count/min/max/sum/std deviation/zscore</span>
<span class="sd">        :param type - this is created in case we want to extend these stats to lookback over a fixed number of rows instead of ranging over column values</span>
<span class="sd">        :param colsToSummarize - list of user-supplied columns to compute stats for. All numeric columns are used if no list is provided</span>
<span class="sd">        :param rangeBackWindowSecs - lookback this many seconds in time to summarize all stats. Note this will look back from the floor of the base event timestamp (as opposed to the exact time since we cast to long)</span>
<span class="sd">        Assumptions:</span>

<span class="sd">        1. The features are summarized over a rolling window that ranges back</span>
<span class="sd">        2. The range back window can be specified by the user</span>
<span class="sd">        3. Sequence numbers are not yet supported for the sort</span>
<span class="sd">        4. There is a cast to long from timestamp so microseconds or more likely breaks down - this could be more easily handled with a string timestamp or sorting the timestamp itself. If using a &#39;rows preceding&#39; window, this wouldn&#39;t be a problem</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># identify columns to summarize if not provided</span>
        <span class="c1"># these should include all numeric columns that</span>
        <span class="c1"># are not the timestamp column and not any of the partition columns</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">colsToSummarize</span><span class="p">:</span>
            <span class="c1"># columns we should never summarize</span>
            <span class="n">prohibited_cols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">:</span>
                <span class="n">prohibited_cols</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pc</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">])</span>
            <span class="c1"># types that can be summarized</span>
            <span class="n">summarizable_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;bigint&quot;</span><span class="p">,</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">]</span>
            <span class="c1"># filter columns to find summarizable columns</span>
            <span class="n">colsToSummarize</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">summarizable_types</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prohibited_cols</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># build window</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;TimestampType&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_double_ts</span><span class="p">()</span>
            <span class="n">prohibited_cols</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;double_ts&quot;</span><span class="p">])</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rangeBetweenWindow</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">rangeBackWindowSecs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sort_col</span><span class="o">=</span><span class="s2">&quot;double_ts&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rangeBetweenWindow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">rangeBackWindowSecs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># compute column summaries</span>
        <span class="n">selectedCols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">derivedCols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">colsToSummarize</span><span class="p">:</span>
            <span class="n">selectedCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;mean_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">))</span>
            <span class="n">selectedCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;count_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">))</span>
            <span class="n">selectedCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;min_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">))</span>
            <span class="n">selectedCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;max_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">))</span>
            <span class="n">selectedCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;sum_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">))</span>
            <span class="n">selectedCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">stddev</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;stddev_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">))</span>
            <span class="n">derivedCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;mean_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">))</span>
                    <span class="o">/</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;stddev_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;zscore_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">selected_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">selectedCols</span><span class="p">)</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">selected_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">selected_df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="o">*</span><span class="n">derivedCols</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="s2">&quot;double_ts&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">summary_df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.withGroupedStats"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.withGroupedStats">[docs]</a>    <span class="k">def</span> <span class="nf">withGroupedStats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metricCols</span><span class="o">=</span><span class="p">[],</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a wider set of stats based on all numeric columns by default</span>
<span class="sd">        Users can choose which columns they want to summarize also. These stats are:</span>
<span class="sd">        mean/count/min/max/sum/std deviation</span>
<span class="sd">        :param metricCols - list of user-supplied columns to compute stats for. All numeric columns are used if no list is provided</span>
<span class="sd">        :param freq - frequency (provide a string of the form &#39;1 min&#39;, &#39;30 seconds&#39; and we interpret the window to use to aggregate</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># identify columns to summarize if not provided</span>
        <span class="c1"># these should include all numeric columns that</span>
        <span class="c1"># are not the timestamp column and not any of the partition columns</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metricCols</span><span class="p">:</span>
            <span class="c1"># columns we should never summarize</span>
            <span class="n">prohibited_cols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">:</span>
                <span class="n">prohibited_cols</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pc</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">])</span>
            <span class="c1"># types that can be summarized</span>
            <span class="n">summarizable_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;bigint&quot;</span><span class="p">,</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">]</span>
            <span class="c1"># filter columns to find summarizable columns</span>
            <span class="n">metricCols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">summarizable_types</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prohibited_cols</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># build window</span>
        <span class="n">parsed_freq</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">checkAllowableFreq</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">agg_window</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">window</span><span class="p">(</span>
            <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">),</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parsed_freq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rs</span><span class="o">.</span><span class="n">freq_dict</span><span class="p">[</span><span class="n">parsed_freq</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
        <span class="p">)</span>

        <span class="c1"># compute column summaries</span>
        <span class="n">selectedCols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metricCols</span><span class="p">:</span>
            <span class="n">selectedCols</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">metric</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;mean_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">),</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">metric</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;count_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">),</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">metric</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;min_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">),</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">metric</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;max_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">),</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">metric</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;sum_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">),</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">stddev</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">metric</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;stddev_&quot;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="n">selected_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">+</span> <span class="p">[</span><span class="n">agg_window</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>
            <span class="o">*</span><span class="n">selectedCols</span>
        <span class="p">)</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">selected_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">selected_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;window&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;window&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">summary_df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">tabName</span><span class="p">,</span> <span class="n">optimizationCols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">tio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">,</span> <span class="n">tabName</span><span class="p">,</span> <span class="n">optimizationCols</span><span class="p">)</span>

<div class="viewcode-block" id="TSDF.resample"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">,</span>
        <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metricCols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">perform_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        function to upsample based on frequency and aggregate function similar to pandas</span>
<span class="sd">        :param freq: frequency for upsample - valid inputs are &quot;hr&quot;, &quot;min&quot;, &quot;sec&quot; corresponding to hour, minute, or second</span>
<span class="sd">        :param func: function used to aggregate input</span>
<span class="sd">        :param metricCols supply a smaller list of numeric columns if the entire set of numeric columns should not be returned for the resample function</span>
<span class="sd">        :param prefix - supply a prefix for the newly sampled columns</span>
<span class="sd">        :param fill - Boolean - set to True if the desired output should contain filled in gaps (with 0s currently)</span>
<span class="sd">        :param perform_checks: calculate time horizon and warnings if True (default is True)</span>
<span class="sd">        :return: TSDF object with sample data using aggregate function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rs</span><span class="o">.</span><span class="n">validateFuncExists</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="c1"># Throw warning for user to validate that the expected number of output rows is valid.</span>
        <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">perform_checks</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">calculate_time_horizon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>

        <span class="n">enriched_df</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">metricCols</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">fill</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">_ResampledTSDF</span><span class="p">(</span>
            <span class="n">enriched_df</span><span class="p">,</span>
            <span class="n">ts_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
            <span class="n">partition_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.interpolate"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">target_cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ts_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">partition_cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_interpolated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">perform_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to interpolate based on frequency, aggregation, and fill similar to pandas. Data will first be aggregated using resample, then missing values</span>
<span class="sd">        will be filled based on the fill calculation.</span>

<span class="sd">        :param freq: frequency for upsample - valid inputs are &quot;hr&quot;, &quot;min&quot;, &quot;sec&quot; corresponding to hour, minute, or second</span>
<span class="sd">        :param func: function used to aggregate input</span>
<span class="sd">        :param method: function used to fill missing values e.g. linear, null, zero, bfill, ffill</span>
<span class="sd">        :param target_cols [optional]: columns that should be interpolated, by default interpolates all numeric columns</span>
<span class="sd">        :param ts_col [optional]: specify other ts_col, by default this uses the ts_col within the TSDF object</span>
<span class="sd">        :param partition_cols [optional]: specify other partition_cols, by default this uses the partition_cols within the TSDF object</span>
<span class="sd">        :param show_interpolated [optional]: if true will include an additional column to show which rows have been fully interpolated.</span>
<span class="sd">        :param perform_checks: calculate time horizon and warnings if True (default is True)</span>
<span class="sd">        :return: new TSDF object containing interpolated data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set defaults for target columns, timestamp column and partition columns when not provided</span>
        <span class="k">if</span> <span class="n">ts_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ts_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span>
        <span class="k">if</span> <span class="n">partition_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">partition_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span>
        <span class="k">if</span> <span class="n">target_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prohibited_cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">partition_cols</span> <span class="o">+</span> <span class="p">[</span><span class="n">ts_col</span><span class="p">]</span>
            <span class="n">summarizable_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;bigint&quot;</span><span class="p">,</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">]</span>

            <span class="c1"># get summarizable find summarizable columns</span>
            <span class="n">target_cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">summarizable_types</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prohibited_cols</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="n">interpolate_service</span><span class="p">:</span> <span class="n">Interpolation</span> <span class="o">=</span> <span class="n">Interpolation</span><span class="p">(</span><span class="n">is_resampled</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tsdf_input</span> <span class="o">=</span> <span class="n">TSDF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">ts_col</span><span class="o">=</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">partition_cols</span><span class="o">=</span><span class="n">partition_cols</span><span class="p">)</span>
        <span class="n">interpolated_df</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="n">interpolate_service</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">tsdf_input</span><span class="p">,</span>
            <span class="n">ts_col</span><span class="p">,</span>
            <span class="n">partition_cols</span><span class="p">,</span>
            <span class="n">target_cols</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">func</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">show_interpolated</span><span class="p">,</span>
            <span class="n">perform_checks</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">interpolated_df</span><span class="p">,</span> <span class="n">ts_col</span><span class="o">=</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">partition_cols</span><span class="o">=</span><span class="n">partition_cols</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">calc_bars</span><span class="p">(</span><span class="n">tsdf</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metricCols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">resample_open</span> <span class="o">=</span> <span class="n">tsdf</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s2">&quot;floor&quot;</span><span class="p">,</span> <span class="n">metricCols</span><span class="o">=</span><span class="n">metricCols</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;open&quot;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span>
        <span class="p">)</span>
        <span class="n">resample_low</span> <span class="o">=</span> <span class="n">tsdf</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">metricCols</span><span class="o">=</span><span class="n">metricCols</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;low&quot;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span>
        <span class="p">)</span>
        <span class="n">resample_high</span> <span class="o">=</span> <span class="n">tsdf</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">metricCols</span><span class="o">=</span><span class="n">metricCols</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;high&quot;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span>
        <span class="p">)</span>
        <span class="n">resample_close</span> <span class="o">=</span> <span class="n">tsdf</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s2">&quot;ceil&quot;</span><span class="p">,</span> <span class="n">metricCols</span><span class="o">=</span><span class="n">metricCols</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;close&quot;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span>
        <span class="p">)</span>

        <span class="n">join_cols</span> <span class="o">=</span> <span class="n">resample_open</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">+</span> <span class="p">[</span><span class="n">resample_open</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span>
        <span class="n">bars</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">resample_open</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resample_high</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">join_cols</span><span class="p">)</span>
            <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resample_low</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">join_cols</span><span class="p">)</span>
            <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resample_close</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">join_cols</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">non_part_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bars</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">resample_open</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">resample_open</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">sel_and_sort</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">resample_open</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">+</span> <span class="p">[</span><span class="n">resample_open</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">non_part_cols</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">bars</span> <span class="o">=</span> <span class="n">bars</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_and_sort</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">bars</span><span class="p">,</span> <span class="n">resample_open</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">resample_open</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">)</span>

<div class="viewcode-block" id="TSDF.fourier_transform"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.fourier_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fourier_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">valueCol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to fourier transform the time series to its frequency domain representation.</span>
<span class="sd">        :param timestep: timestep value to be used for getting the frequency scale</span>
<span class="sd">        :param valueCol: name of the time domain data column which will be transformed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">tempo_fourier_util</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This method is a vanilla python logic implementing fourier transform on a numpy array using the scipy module.</span>
<span class="sd">            This method is meant to be called from Tempo TSDF as a pandas function API on Spark</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">select_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pdf</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">pdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tpoints&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="s2">&quot;tdval&quot;</span><span class="p">])</span>
            <span class="n">tran</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">tran</span><span class="o">.</span><span class="n">real</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">tran</span><span class="o">.</span><span class="n">imag</span>
            <span class="n">pdf</span><span class="p">[</span><span class="s2">&quot;ft_real&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">pdf</span><span class="p">[</span><span class="s2">&quot;ft_imag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">tran</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">xf</span> <span class="o">=</span> <span class="n">fftfreq</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">timestep</span><span class="p">)</span>
            <span class="n">pdf</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xf</span>
            <span class="k">return</span> <span class="n">pdf</span><span class="p">[</span><span class="n">select_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_real&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_imag&quot;</span><span class="p">]]</span>

        <span class="n">valueCol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__validated_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">valueCol</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;dummy_group&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot;dummy_val&quot;</span><span class="p">))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;dummy_group&quot;</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">,</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">valueCol</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;tdval&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">valueCol</span><span class="p">))</span>
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;tpoints&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">return_schema</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtypes</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;freq double&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_real double&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_imag double&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="s2">&quot;dummy_group&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">applyInPandas</span><span class="p">(</span>
                    <span class="n">tempo_fourier_util</span><span class="p">,</span> <span class="n">return_schema</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;dummy_group&quot;</span><span class="p">,</span> <span class="s2">&quot;tdval&quot;</span><span class="p">,</span> <span class="s2">&quot;tpoints&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">group_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">valueCol</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;tdval&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">valueCol</span><span class="p">))</span>
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;tpoints&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">return_schema</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtypes</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;freq double&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_real double&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_imag double&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="o">*</span><span class="n">group_cols</span><span class="p">)</span><span class="o">.</span><span class="n">applyInPandas</span><span class="p">(</span>
                    <span class="n">tempo_fourier_util</span><span class="p">,</span> <span class="n">return_schema</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;tdval&quot;</span><span class="p">,</span> <span class="s2">&quot;tpoints&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;dummy_group&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="s2">&quot;dummy_val&quot;</span><span class="p">))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;dummy_group&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">valueCol</span><span class="p">))</span>
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;tdval&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">valueCol</span><span class="p">))</span>
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;tpoints&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">return_schema</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtypes</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;freq double&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_real double&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_imag double&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="s2">&quot;dummy_group&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">applyInPandas</span><span class="p">(</span>
                    <span class="n">tempo_fourier_util</span><span class="p">,</span> <span class="n">return_schema</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;dummy_group&quot;</span><span class="p">,</span> <span class="s2">&quot;tdval&quot;</span><span class="p">,</span> <span class="s2">&quot;tpoints&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">group_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">valueCol</span><span class="p">))</span>
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;tdval&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">valueCol</span><span class="p">))</span>
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;tpoints&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">return_schema</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtypes</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;freq double&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_real double&quot;</span><span class="p">,</span> <span class="s2">&quot;ft_imag double&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="o">*</span><span class="n">group_cols</span><span class="p">)</span><span class="o">.</span><span class="n">applyInPandas</span><span class="p">(</span>
                    <span class="n">tempo_fourier_util</span><span class="p">,</span> <span class="n">return_schema</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;tdval&quot;</span><span class="p">,</span> <span class="s2">&quot;tpoints&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_col</span><span class="p">)</span></div>

<div class="viewcode-block" id="TSDF.extractStateIntervals"><a class="viewcode-back" href="../../reference/tempo.tsdf.html#tempo.tsdf.TSDF.extractStateIntervals">[docs]</a>    <span class="k">def</span> <span class="nf">extractStateIntervals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">metric_cols</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">state_definition</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Column</span><span class="p">,</span> <span class="n">Column</span><span class="p">],</span> <span class="n">Column</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts intervals from a :class:`~tsdf.TSDF` based on some notion of &quot;state&quot;, as defined by the :param</span>
<span class="sd">        state_definition: parameter. The state definition consists of a comparison operation between the current and</span>
<span class="sd">        previous values of a metric. If the comparison operation evaluates to true across all metric columns,</span>
<span class="sd">        then we consider both points to be in the same &quot;state&quot;. Changes of state occur when the comparison operator</span>
<span class="sd">        returns false for any given metric column. So, the default state definition (&#39;=&#39;) entails that intervals of</span>
<span class="sd">        time wherein the metrics all remained constant. A state definition of &#39;&gt;=&#39; would extract intervals wherein</span>
<span class="sd">        the metrics were all monotonically increasing.</span>

<span class="sd">        :param: metric_cols: the set of metric columns to evaluate for state changes</span>
<span class="sd">        :param: state_definition: the comparison function used to evaluate individual metrics for state changes.</span>
<span class="sd">        Either a string, giving a standard PySpark column comparison operation, or a binary function with the</span>
<span class="sd">        signature: `(x1: Column, x2: Column) -&gt; Column` where the returned column expression evaluates to a</span>
<span class="sd">        :class:`~pyspark.sql.types.BooleanType`</span>

<span class="sd">        :return: a :class:`~pyspark.sql.DataFrame` object containing the resulting intervals</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># https://spark.apache.org/docs/latest/sql-ref-null-semantics.html#comparison-operators-</span>
        <span class="k">def</span> <span class="nf">null_safe_equals</span><span class="p">(</span><span class="n">col1</span><span class="p">:</span> <span class="n">Column</span><span class="p">,</span> <span class="n">col2</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">f</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">col1</span><span class="o">.</span><span class="n">isNull</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">col2</span><span class="o">.</span><span class="n">isNull</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
                <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">col1</span><span class="o">.</span><span class="n">isNull</span><span class="p">()</span> <span class="o">|</span> <span class="n">col2</span><span class="o">.</span><span class="n">isNull</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
                <span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">operator_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_2</span>
            <span class="s2">&quot;!=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_11</span>
            <span class="s2">&quot;&lt;&gt;&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_8</span>
            <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_9</span>
            <span class="s2">&quot;&lt;=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_10</span>
            <span class="s2">&quot;&lt;=&gt;&quot;</span><span class="p">:</span> <span class="n">null_safe_equals</span><span class="p">,</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_12</span>
            <span class="s2">&quot;=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_13</span>
            <span class="s2">&quot;==&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_14</span>
            <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span>
            <span class="c1"># https://spark.apache.org/docs/latest/api/sql/#_15</span>
            <span class="s2">&quot;&gt;=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Validate state definition and construct state comparison function</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">state_definition</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state_definition</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operator_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid comparison operator for `state_definition` argument: </span><span class="si">{</span><span class="n">state_definition</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="k">def</span> <span class="nf">state_comparison_fn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">operator_dict</span><span class="p">[</span><span class="n">state_definition</span><span class="p">](</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">state_definition</span><span class="p">):</span>
            <span class="n">state_comparison_fn</span> <span class="o">=</span> <span class="n">state_definition</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The `state_definition` argument can be of type `str` or `callable`, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but received value of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">state_definition</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__baseWindow</span><span class="p">()</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>

        <span class="c1"># Get previous timestamp to identify start time of the interval</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
            <span class="s2">&quot;previous_ts&quot;</span><span class="p">,</span>
            <span class="n">f</span><span class="o">.</span><span class="n">lag</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Determine state intervals using user-provided the state comparison function</span>
        <span class="c1"># The comparison occurs on the current and previous record per metric column</span>
        <span class="n">temp_metric_compare_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mc</span> <span class="ow">in</span> <span class="n">metric_cols</span><span class="p">:</span>
            <span class="n">temp_metric_compare_col</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">mc</span><span class="si">}</span><span class="s2">_compare&quot;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="n">temp_metric_compare_col</span><span class="p">,</span>
                <span class="n">state_comparison_fn</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">mc</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">lag</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">mc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">)),</span>
            <span class="p">)</span>
            <span class="n">temp_metric_compare_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_metric_compare_col</span><span class="p">)</span>

        <span class="c1"># Remove first record which will have no state change</span>
        <span class="c1"># and produces `null` for all state comparisons</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;previous_ts&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isNotNull</span><span class="p">())</span>

        <span class="c1"># Each state comparison should return True if state remained constant</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
            <span class="s2">&quot;state_change&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">array_contains</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">*</span><span class="n">temp_metric_compare_cols</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Count the distinct state changes to get the unique intervals</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
            <span class="s2">&quot;state_incrementer&quot;</span><span class="p">,</span>
            <span class="n">f</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;state_change&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">~</span><span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;state_change&quot;</span><span class="p">))</span>

        <span class="c1"># Find the start and end timestamp of the interval</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span> <span class="s2">&quot;state_incrementer&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">agg</span><span class="p">(</span>
                <span class="n">f</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="s2">&quot;previous_ts&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;start_ts&quot;</span><span class="p">),</span>
                <span class="n">f</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;end_ts&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;state_incrementer&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div></div>


<span class="k">class</span> <span class="nc">_ResampledTSDF</span><span class="p">(</span><span class="n">TSDF</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">ts_col</span><span class="o">=</span><span class="s2">&quot;event_ts&quot;</span><span class="p">,</span>
        <span class="n">partition_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sequence_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_ResampledTSDF</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">ts_col</span><span class="p">,</span> <span class="n">partition_cols</span><span class="p">,</span> <span class="n">sequence_col</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">target_cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_interpolated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">perform_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to interpolate based on frequency, aggregation, and fill similar to pandas. This method requires an already sampled data set in order to use.</span>

<span class="sd">        :param method: function used to fill missing values e.g. linear, null, zero, bfill, ffill</span>
<span class="sd">        :param target_cols [optional]: columns that should be interpolated, by default interpolates all numeric columns</span>
<span class="sd">        :param show_interpolated [optional]: if true will include an additional column to show which rows have been fully interpolated.</span>
<span class="sd">        :param perform_checks: calculate time horizon and warnings if True (default is True)</span>
<span class="sd">        :return: new TSDF object containing interpolated data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set defaults for target columns, timestamp column and partition columns when not provided</span>
        <span class="k">if</span> <span class="n">target_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prohibited_cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">]</span>
            <span class="n">summarizable_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;bigint&quot;</span><span class="p">,</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">]</span>

            <span class="c1"># get summarizable find summarizable columns</span>
            <span class="n">target_cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">summarizable_types</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prohibited_cols</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="n">interpolate_service</span><span class="p">:</span> <span class="n">Interpolation</span> <span class="o">=</span> <span class="n">Interpolation</span><span class="p">(</span><span class="n">is_resampled</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tsdf_input</span> <span class="o">=</span> <span class="n">TSDF</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">ts_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">partition_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span>
        <span class="p">)</span>
        <span class="n">interpolated_df</span> <span class="o">=</span> <span class="n">interpolate_service</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">tsdf</span><span class="o">=</span><span class="n">tsdf_input</span><span class="p">,</span>
            <span class="n">ts_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span>
            <span class="n">partition_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span><span class="p">,</span>
            <span class="n">target_cols</span><span class="o">=</span><span class="n">target_cols</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__freq</span><span class="p">,</span>
            <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__func</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">show_interpolated</span><span class="o">=</span><span class="n">show_interpolated</span><span class="p">,</span>
            <span class="n">perform_checks</span><span class="o">=</span><span class="n">perform_checks</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">TSDF</span><span class="p">(</span>
            <span class="n">interpolated_df</span><span class="p">,</span> <span class="n">ts_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ts_col</span><span class="p">,</span> <span class="n">partition_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partitionCols</span>
        <span class="p">)</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, Databricks Labs
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/databrickslabs/tempo" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              <a class="muted-link fa-brands fa-uncharted" href="https://databricks.com/learn/labs" aria-label="Databricks Labs"></a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    </body>
</html>